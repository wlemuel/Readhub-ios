//
//  HomePresenter.swift
//  readhub
//
//  Created by Steve Lemuel on 10/15/19.
//  Copyright (c) 2019 Steve Lemuel. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import NSObject_Rx
import RxCocoa
import RxSwift
import UIKit

final class HomePresenter {
    // MARK: - Public prperties -

    var topics = BehaviorRelay<[TopicItemModel]>(value: [])
    var news = BehaviorRelay<[NewsItemModel]>(value: [])
    var technews = BehaviorRelay<[NewsItemModel]>(value: [])
    var blockchains = BehaviorRelay<[NewsItemModel]>(value: [])

    var errors = PublishSubject<ReadhubApiError>()
    var notifies = PublishSubject<NewsType>()

    // MARK: - Private properties -

    private unowned let view: HomeViewInterface
    private let interactor: HomeInteractorInterface
    private let wireframe: HomeWireframeInterface

    private var timer: Disposable?

    private let disposeBag = DisposeBag()

    // MARK: - Lifecycle -

    init(view: HomeViewInterface, interactor: HomeInteractorInterface, wireframe: HomeWireframeInterface) {
        self.view = view
        self.interactor = interactor
        self.wireframe = wireframe
    }
}

// MARK: - Extensions -

extension HomePresenter: HomePresenterInterface {
    func configure(with output: Home.ViewOutput) -> Home.ViewInput {
        return Home.ViewInput()
    }

    func getTopicList(lastCursor: String, _ refresh: Bool) {
        interactor.getTopicList(lastCursor: lastCursor, pageSize: 20)
            .subscribe(onSuccess: { [weak self] topicData in
                guard let `self` = self else { return }

                guard let topicList = topicData.data else {
                    self.errors.onNext(.noData(newsType: .topic))
                    return
                }

                if refresh {
                    self.topics.accept(topicList)
                } else {
                    self.topics.accept(self.topics.value + topicList)
                }

            }) { [weak self] error in
                guard let `self` = self else { return }
                print(error)

                self.errors.onNext(.serverFailed(newsType: .topic))

            }.disposed(by: disposeBag)
    }

    func toggleTopicCellAt(index: Int) {
        var topicList = topics.value + []

        if index >= topicList.count {
            return
        }

        topicList[index].expanded = !topicList[index].expanded

        topics.accept(topicList)
    }

    func getNewsList(lastCursor: String, _ refresh: Bool) {
        interactor.getNewsList(lastCursor: lastCursor, pageSize: 20)
            .subscribe(onSuccess: { [weak self] newsData in
                guard let `self` = self else { return }

                guard let newsList = newsData.data else {
                    self.errors.onNext(.noData(newsType: .news))
                    return
                }

                if refresh {
                    self.news.accept(newsList)
                } else {
                    self.news.accept(self.news.value + newsList)
                }
            }) { [weak self] error in
                guard let `self` = self else { return }
                print(error)

                self.errors.onNext(.serverFailed(newsType: .news))
            }.disposed(by: disposeBag)
    }

    func getTechnewsList(lastCursor: String, _ refresh: Bool) {
        interactor.getTechnewsList(lastCursor: lastCursor, pageSize: 20)
            .subscribe(onSuccess: { [weak self] technewsList in
                guard let `self` = self else { return }

                if refresh {
                    self.technews.accept(technewsList.data ?? [])
                } else {
                    self.technews.accept(self.technews.value + (technewsList.data ?? []))
                }

            }) { [weak self] error in
                guard let `self` = self else { return }
                print(error)

                self.errors.onNext(.serverFailed(newsType: .technews))
            }.disposed(by: disposeBag)
    }

    func getBlockchainList(lastCursor: String, _ refresh: Bool) {
        interactor.getBlockchainList(lastCursor: lastCursor, pageSize: 20)
            .subscribe(onSuccess: { [weak self] blockchainList in
                guard let `self` = self else { return }

                if refresh {
                    self.blockchains.accept(blockchainList.data ?? [])
                } else {
                    self.blockchains.accept(self.blockchains.value + (blockchainList.data ?? []))
                }
            }) { [weak self] error in
                guard let `self` = self else { return }
                print(error)

                self.errors.onNext(.serverFailed(newsType: .blockchain))
            }.disposed(by: disposeBag)
    }

    func startUpdateCheck() {
        timer = Observable<Int>.interval(.seconds(5 * 60), scheduler: SerialDispatchQueueScheduler(qos: .default)).subscribe { [weak self] _ in
            guard let `self` = self else { return }

            self.checkTopics()
            self.checkNews()
            self.checkTechnews()
            self.checkBlockchains()
        }

        timer?.disposed(by: disposeBag)
    }

    func stopUpdateCheck() {
        timer?.dispose()
    }

    private func checkTopics() {
        interactor.getTopicList(lastCursor: "", pageSize: 1)
            .subscribe(onSuccess: { [weak self] topicData in
                guard let `self` = self else { return }

                if let topicList = topicData.data {
                    if self.topics.value.count > 0 && topicList.count > 0 &&
                        self.topics.value[0].id != topicList[0].id {
                        self.notifies.onNext(.topic)
                    }
                }
            }).disposed(by: disposeBag)
    }

    private func checkNews() {
        interactor.getNewsList(lastCursor: "", pageSize: 1)
            .subscribe(onSuccess: { [weak self] newsData in
                guard let `self` = self else { return }

                // check whether there are news updated
                if let newsList = newsData.data {
                    if self.news.value.count > 0 && newsList.count > 0 &&
                        self.news.value[0].id != newsList[0].id {
                        self.notifies.onNext(.news)
                    }
                }
            }).disposed(by: disposeBag)
    }

    private func checkTechnews() {
        interactor.getTechnewsList(lastCursor: "", pageSize: 1)
            .subscribe(onSuccess: { [weak self] newsData in
                guard let `self` = self else { return }

                // check whether there are news updated
                if let newsList = newsData.data {
                    if self.technews.value.count > 0 && newsList.count > 0 &&
                        self.technews.value[0].id != newsList[0].id {
                        self.notifies.onNext(.technews)
                    }
                }
            }).disposed(by: disposeBag)
    }

    private func checkBlockchains() {
        interactor.getBlockchainList(lastCursor: "", pageSize: 1)
            .subscribe(onSuccess: { [weak self] newsData in
                guard let `self` = self else { return }

                if let newsList = newsData.data {
                    if self.blockchains.value.count > 0 && newsList.count > 0 &&
                        self.blockchains.value[0].id != newsList[0].id {
                        self.notifies.onNext(.blockchain)
                    }
                }
            }).disposed(by: disposeBag)
    }
}
