//
//  HomePresenter.swift
//  readhub
//
//  Created by Steve Lemuel on 10/15/19.
//  Copyright (c) 2019 Steve Lemuel. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import NSObject_Rx
import RxCocoa
import RxSwift
import UIKit

final class HomePresenter {
    // MARK: - Public prperties -

    var topics = BehaviorRelay<[TopicItemModel]>(value: [])
    var news = BehaviorRelay<[NewsItemModel]>(value: [])
    var technews = BehaviorRelay<[NewsItemModel]>(value: [])
    var blockchains = BehaviorRelay<[NewsItemModel]>(value: [])

    var errors = PublishSubject<ReadhubApiError>()

    // MARK: - Private properties -

    private unowned let view: HomeViewInterface
    private let interactor: HomeInteractorInterface
    private let wireframe: HomeWireframeInterface

    private let disposeBag = DisposeBag()

    // MARK: - Lifecycle -

    init(view: HomeViewInterface, interactor: HomeInteractorInterface, wireframe: HomeWireframeInterface) {
        self.view = view
        self.interactor = interactor
        self.wireframe = wireframe
    }
}

// MARK: - Extensions -

extension HomePresenter: HomePresenterInterface {
    func configure(with output: Home.ViewOutput) -> Home.ViewInput {
        return Home.ViewInput()
    }

    func getTopicList(lastCursor: String, _ refresh: Bool) {
        interactor.getTopicList(lastCursor: lastCursor, pageSize: 20)
            .subscribe(onSuccess: { [weak self] topicData in
                guard let `self` = self else { return }

                guard let topicList = topicData.data else {
                    self.errors.onNext(.noData(newsType: .topic))
                    return
                }

                if refresh {
                    self.topics.accept(topicList)
                } else {
                    self.topics.accept(self.topics.value + topicList)
                }

            }) { [weak self] error in
                guard let `self` = self else { return }
                print(error)

                self.errors.onNext(.serverFailed(newsType: .topic))

            }.disposed(by: disposeBag)
    }

    func toggleTopicCellAt(index: Int) {
        var topicList = topics.value + []

        if index >= topicList.count {
            return
        }

        topicList[index].expanded = !topicList[index].expanded

        topics.accept(topicList)
    }

    func getNewsList(lastCursor: String, _ refresh: Bool) {
        interactor.getNewsList(lastCursor: lastCursor, pageSize: 20)
            .subscribe(onSuccess: { [weak self] newsData in
                guard let `self` = self else { return }

                guard let newsList = newsData.data else {
                    self.errors.onNext(.noData(newsType: .news))
                    return
                }

                if refresh {
                    self.news.accept(newsList)
                } else {
                    self.news.accept(self.news.value + newsList)
                }
            }) { [weak self] error in
                guard let `self` = self else { return }
                print(error)

                self.errors.onNext(.serverFailed(newsType: .news))
            }.disposed(by: disposeBag)
    }

    func getTechnewsList(lastCursor: String, _ refresh: Bool) {
        interactor.getTechnewsList(lastCursor: lastCursor, pageSize: 20)
            .subscribe(onSuccess: { [weak self] technewsList in
                guard let `self` = self else { return }

                if refresh {
                    self.technews.accept(technewsList.data ?? [])
                } else {
                    self.technews.accept(self.technews.value + (technewsList.data ?? []))
                }

            }) { [weak self] error in
                guard let `self` = self else { return }
                print(error)

                self.errors.onNext(.serverFailed(newsType: .technews))
            }.disposed(by: disposeBag)
    }

    func getBlockchainList(lastCursor: String, _ refresh: Bool) {
        interactor.getBlockchainList(lastCursor: lastCursor, pageSize: 20)
            .subscribe(onSuccess: { [weak self] blockchainList in
                guard let `self` = self else { return }

                if refresh {
                    self.blockchains.accept(blockchainList.data ?? [])
                } else {
                    self.blockchains.accept(self.blockchains.value + (blockchainList.data ?? []))
                }
            }) { [weak self] error in
                guard let `self` = self else { return }
                print(error)

                self.errors.onNext(.serverFailed(newsType: .blockchain))
            }.disposed(by: disposeBag)
    }
}
